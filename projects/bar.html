<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All you can eat bar thingies!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Audiowide&display=swap');
        body {
            font-family: 'Audiowide', sans-serif;
        }
    </style>
</head>
<body>

<div>
    <h1>All you can eat bar thingies!</h1>

    <!-- Color Controls -->
    <div>
        <label>Color Scheme:</label>
        <button onclick="changeColor('dragonfruit')">Dragonfruit</button>
        <button onclick="changeColor('blueberry')">Blueberry</button>
    </div>

    <hr style="margin: 20px 0;">

    <!-- Resize Controls -->
    <div>
        <label for="resizeAmount">
            Set Total Width (px):
        </label>
        <input type="number" id="resizeAmount" value="529" min="50" max="1500" />
        <button onclick="resizeParallelogram()">
            Apply Resize
        </button>
    </div>
    
    <hr style="margin: 20px 0;">

    <!-- Flip Controls -->
    <div>
        <button onclick="flipParallelogram()">Flip Parallelogram (Kinda Broken)</button>
    </div>

    <hr style="margin: 20px 0;">

    <div id="svgContainer">
        <!-- The Original SVG code provided by the user -->
        <svg id="parallelogramSVG" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
             width="528.88638" height="83.80404" viewBox="0,0,528.88638,83.80404"
             data-original-width="528.88638" data-original-viewbox-width="528.88638"
             style="max-width: 100%; height: auto; border: 1px solid #ccc;">
            <defs>
                <linearGradient x1="318.97112" y1="139.95" x2="318.97112" y2="215.45811" gradientUnits="userSpaceOnUse" id="color-1"><stop offset="0" stop-color="#ff9494"/><stop offset="1" stop-color="#ff96c5"/></linearGradient>
                <linearGradient x1="318.97112" y1="145.99596" x2="318.97112" y2="209.41215" gradientUnits="userSpaceOnUse" id="color-2"><stop offset="0" stop-color="#fe0000"/><stop offset="1" stop-color="#ff0088"/></linearGradient>
                <linearGradient x1="339.09569" y1="177.4581" x2="339.09569" y2="139.70403" gradientUnits="userSpaceOnUse" id="color-3"><stop offset="0" stop-color="#ffffff" stop-opacity="0.32157"/><stop offset="1" stop-color="#ffffff" stop-opacity="0"/></linearGradient>
                <linearGradient x1="338.66942" y1="138.49593" x2="338.66945" y2="153.49599" gradientUnits="userSpaceOnUse" id="color-4"><stop offset="0" stop-color="#ffffff"/><stop offset="1" stop-color="#ffffff" stop-opacity="0"/></linearGradient>
                <linearGradient x1="318.97109" y1="139.95" x2="318.97109" y2="215.45811" gradientUnits="userSpaceOnUse" id="color-5"><stop offset="0" stop-color="#a81b1b"/><stop offset="1" stop-color="#9e2045"/></linearGradient>
            </defs>
            <g transform="translate(-54.52793,-137.7)">
                <g data-paper-data="{&quot;isPaintingLayer&quot;:true}" fill-rule="nonzero" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="10" stroke-dasharray="" stroke-dashoffset="0" style="mix-blend-mode: normal">
                    <!-- Path 1: Main background fill (Inner) -->
                    <path id="path1" d="M502.47428,215.45811h-442.51431l75.50811,-75.50811h442.51431l-75.50808,75.50808z" fill="url(#color-1)" stroke="none" stroke-width="0"/>
                    
                    <!-- Path 2: Inner gradient fill -->
                    <path id="path2" d="M500.42831,209.41215h-426.33048l63.41619,-63.41619h426.33045l-63.41616,63.41616z" fill="url(#color-2)" stroke="none" stroke-width="0"/>
                    
                    <!-- Path 3: Outer shadow/outline -->
                    <path id="path3" d="M504.53198,221.50404h-442.51431l75.50811,-75.50811h442.51431l-75.50808,75.50808z" fill-opacity="0.32157" fill="#ff0000" stroke="none" stroke-width="0"/>
                    
                    <!-- Path 4: Top highlight 1 -->
                    <path id="path4" d="M577.97069,139.70406l-38.625,37.75404h-441l37.5,-37.75404z" fill="url(#color-3)" stroke="none" stroke-width="0"/>
                    
                    <!-- Path 5: Top highlight 2 -->
                    <path id="path5" d="M124.22537,153.49593l11.14287,-14.99997h443.031l-13.28571,15z" fill="url(#color-4)" stroke="none" stroke-width="0"/>
                    
                    <!-- Path 6: Outline stroke -->
                    <path id="path6" d="M59.95991,215.45811l75.50811,-75.50811h442.51431l-75.50808,75.50808z" fill="none" stroke="url(#color-5)" stroke-width="4.5"/>
                </g>
            </g>
        </svg>
    </div>

    <hr style="margin: 20px 0;">
    
    <!-- Export Controls -->
    <div>
        <button onclick="exportSVG()">
            Export SVG
        </button>
    </div>
<p>i didnt add text yet but use audiowide regular for it it fits best</p>
</div>

<script>
    const colorSchemes = {
        dragonfruit: {
            'color-1': ['#ff9494', '#ff96c5'],
            'color-2': ['#fe0000', '#ff0088'],
            'color-5': ['#a81b1b', '#9e2045'],
            'path3-fill': '#ff0000'
        },
        blueberry: {
            'color-1': ['#e494ff', '#97bfff'],
            'color-2': ['#ee35ff', '#00bfff'],
            'color-5': ['#89209f', '#301ca8'],
            'path3-fill': '#5d00ff'
        }
    };

    // Initial path data parameters for horizontal segments (M-X and H-length)
    const initialPaths = {
        'path1': { startX: 502.47428, hLength: 442.51431 },
        'path2': { startX: 500.42831, hLength: 426.33048 },
        'path3': { startX: 504.53198, hLength: 442.51431 },
        'path4': { startX: 577.97069, hLength: -441 },
        'path5': { hLength: 443.031 }, 
        'path6': { hLength: 442.51431 },
    };

    const svgElement = document.getElementById('parallelogramSVG');
    const originalSvgWidth = parseFloat(svgElement.getAttribute('data-original-width'));
    const originalViewBoxWidth = parseFloat(svgElement.getAttribute('data-original-viewbox-width'));

    /**
     * Changes the color scheme of the SVG.
     * @param {string} schemeName - The name of the color scheme ('dragonfruit' or 'blueberry').
     */
    function changeColor(schemeName) {
        const scheme = colorSchemes[schemeName];
        if (!scheme) return;

        // Update gradients
        for (const id in scheme) {
            if (id.startsWith('color-')) {
                const gradient = document.getElementById(id);
                if (gradient) {
                    const stops = gradient.getElementsByTagName('stop');
                    if(stops[0]) stops[0].setAttribute('stop-color', scheme[id][0]);
                    if(stops[1]) stops[1].setAttribute('stop-color', scheme[id][1]);
                }
            }
        }
        
        // Update solid fill
        const path3 = document.getElementById('path3');
        if (path3 && scheme['path3-fill']) {
            path3.setAttribute('fill', scheme['path3-fill']);
        }
    }


    /**
     * Flips each path of the parallelogram instantly.
     */
    function flipParallelogram() {
        const targetWidth = parseFloat(document.getElementById('resizeAmount').value) || originalSvgWidth;
        const deltaX = targetWidth - originalSvgWidth;
        const centerX = 318.97112 + (deltaX / 2);
        const flipTransform = `translate(${centerX}, 0) scale(-1, 1) translate(-${centerX}, 0)`;

        for (let i = 1; i <= 6; i++) {
            const path = document.getElementById(`path${i}`);
            if (!path) continue;

            const isFlipped = path.getAttribute('data-flipped') === 'true';

            if (isFlipped) {
                path.removeAttribute('transform');
                path.setAttribute('data-flipped', 'false');
            } else {
                path.setAttribute('transform', flipTransform);
                path.setAttribute('data-flipped', 'true');
            }
        }
    }

    /**
     * Resizes the parallelogram horizontally by setting its total width.
     */
    function resizeParallelogram() {
        // The target width is now the absolute value from the input field.
        const targetWidth = parseFloat(document.getElementById('resizeAmount').value) || originalSvgWidth;
        // The delta is the difference between the target and the original width.
        const deltaX = targetWidth - originalSvgWidth;
        
        // 1. Update SVG width and viewBox
        const newSvgWidth = originalSvgWidth + deltaX; // This resolves to targetWidth
        const newViewBoxWidth = originalViewBoxWidth + deltaX;
        
        svgElement.setAttribute('width', newSvgWidth);
        svgElement.setAttribute('viewBox', `0,0,${newViewBoxWidth},83.80404`);
        
        // 2. Iterate and update key paths based on the calculated deltaX
        for (const id in initialPaths) {
            const pathData = initialPaths[id];
            const pathElement = document.getElementById(id);
            let newD = '';

            if (!pathElement) continue;

            const originalD = pathElement.getAttribute('data-original-d') || pathElement.getAttribute('d');
            if (!pathElement.hasAttribute('data-original-d')) {
                pathElement.setAttribute('data-original-d', originalD);
            }

            if (id === 'path1' || id === 'path2' || id === 'path3') {
                const newStartX = (pathData.startX + deltaX).toFixed(5);
                const newHLength = (pathData.hLength + deltaX).toFixed(5);
                const parts = originalD.match(/M([\d\.]+),([\d\.]+)h-([\d\.]+)l([\d\.]+),([\-\d\.]+)h([\d\.]+)l([\-\d\.]+),([\d\.]+)z/);
                if (parts) {
                    newD = `M${newStartX},${parts[2]}h-${newHLength}l${parts[4]},${parts[5]}h${newHLength}l${parts[7]},${parts[8]}z`;
                }
            } else if (id === 'path4') {
                const newStartX = (pathData.startX + deltaX).toFixed(5);
                const newHLength = (pathData.hLength - deltaX).toFixed(5);
                const parts = originalD.match(/M([\d\.]+),([\d\.]+)l([\-\d\.]+),([\d\.]+)h([\-\d\.]+)l([\d\.]+),([\-\d\.]+)z/);
                if (parts) {
                    newD = `M${newStartX},${parts[2]}l${parts[3]},${parts[4]}h${newHLength}l${parts[6]},${parts[7]}z`;
                }
            } else if (id === 'path5' || id === 'path6') {
                const newHLength = (pathData.hLength + deltaX).toFixed(5);
                const hSegmentIndex = originalD.indexOf('h');
                if (hSegmentIndex !== -1) {
                    const hValueMatch = originalD.substring(hSegmentIndex).match(/h([\d\.\-]+)/);
                    if (hValueMatch) {
                        newD = originalD.replace(hValueMatch[0], `h${newHLength}`);
                    }
                }
            }
            
            if (newD) {
                pathElement.setAttribute('d', newD);
            }
        }
        
        // 3. After resizing, re-apply the flip transform if needed
        const newCenterX = 318.97112 + (deltaX / 2);
        const newFlipTransform = `translate(${newCenterX}, 0) scale(-1, 1) translate(-${newCenterX}, 0)`;
        for (let i = 1; i <= 6; i++) {
            const path = document.getElementById(`path${i}`);
            if (path && path.getAttribute('data-flipped') === 'true') {
                path.setAttribute('transform', newFlipTransform);
            }
        }
    }

    /**
     * Exports the current SVG element to a file.
     */
    function exportSVG() {
        const svgEl = document.getElementById('parallelogramSVG');
        const fileName = "bar to have fun with.svg";

        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgEl);

        const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
    }

    window.onload = function() {
        // Set the input field to the SVG's original width on page load.
        document.getElementById('resizeAmount').value = Math.round(originalSvgWidth);
        resizeParallelogram();
    };

</script>

</body>
</html>

